---
status: pending
priority: p1
issue_id: "004"
tags: [security, code-review, vulnerability, critical]
dependencies: []
---

# Fix Path Traversal Vulnerability in File Handling

SECURITY: Critical path traversal vulnerability allows reading arbitrary files.

## Problem Statement

Multiple functions in `analysis.py` accept file paths without validation, allowing directory traversal attacks. An attacker could use paths like `../../etc/passwd` to read arbitrary files on the system.

**Security Impact:**
- **HIGH SEVERITY** - Path traversal vulnerability (CWE-22)
- Allows reading sensitive files outside intended directories
- Could expose configuration, credentials, or system files
- Violates principle of least privilege

## Findings

**Vulnerable locations:**
- `analysis.py:723` - `parse_mulliken_population(output_file)` - No path validation
- `analysis.py:814` - `parse_job_metrics(output_path)` - No path validation
- `check_multi_spin.py` - Accepts user-provided paths without validation

**Attack vector:**
```python
# Attacker provides malicious path
result = parse_mulliken_population("../../../../etc/passwd")
# Function opens and reads arbitrary file
```

**Identified by:** security-sentinel agent during code review

## Proposed Solutions

### Option 1: Validate and Resolve Paths (Recommended)

**Approach:** Use `Path.resolve()` and verify path is within allowed directory

```python
from pathlib import Path

def parse_mulliken_population(output_file: str | Path) -> dict[str, list] | None:
    # Resolve to absolute path and check containment
    file_path = Path(output_file).resolve()

    # Optional: restrict to specific directories
    allowed_base = Path.cwd()  # or specific work directory
    try:
        file_path.relative_to(allowed_base)
    except ValueError:
        raise ValueError(f"Path {file_path} is outside allowed directory")

    # Verify file exists and is a file
    if not file_path.is_file():
        raise ValueError(f"Invalid file path: {file_path}")

    # Now safe to open
    with open(file_path) as f:
        # ... rest of logic
```

**Pros:**
- Prevents directory traversal
- Validates file existence
- Clear error messages
- Follows security best practices

**Cons:**
- Adds validation overhead
- Need to define "allowed" directories
- May break existing code if paths were not validated before

**Effort:** 2-3 hours

**Risk:** Medium (behavior change)

---

### Option 2: Use Safe File Opening Wrapper

**Approach:** Create a `safe_open()` utility function

```python
def safe_open(path: str | Path, allowed_base: Path) -> TextIO:
    """Safely open a file with path validation."""
    file_path = Path(path).resolve()
    if not file_path.is_relative_to(allowed_base):
        raise ValueError(f"Path outside allowed directory: {file_path}")
    return open(file_path, 'r')
```

**Pros:**
- Centralized validation logic
- Reusable across codebase
- Easy to audit

**Cons:**
- Requires refactoring all file opens
- Need to determine allowed_base for each use case

**Effort:** 3-4 hours

**Risk:** Medium

---

### Option 3: Add Path Validation Decorator

**Approach:** Create decorator to validate paths automatically

**Pros:**
- Clean separation of concerns
- Applies validation declaratively

**Cons:**
- More complex
- Decorator overhead
- Harder to debug

**Effort:** 4-5 hours

**Risk:** High

## Recommended Action

**To be filled during triage.**

## Technical Details

**Vulnerable functions:**
1. `parse_mulliken_population(output_file)` - line 723
2. `parse_job_metrics(output_path)` - line 814
3. `parse_max_forces(output_file)` - likely vulnerable
4. `parse_scf_steps(output_file)` - likely vulnerable
5. `parse_final_energy(output_file)` - likely vulnerable

**Attack scenarios:**
- User provides `../../etc/passwd` as output_file
- Workflow reads malicious paths from untrusted CSV
- Database contains injected paths from previous runs

**Mitigation requirements:**
- Validate all user-provided paths
- Resolve symlinks with `.resolve()`
- Check path is within allowed directories
- Verify file exists and is a regular file
- Never trust user input

## Resources

- **PR:** feature/mulliken-population-analysis
- **Code review:** security-sentinel agent finding
- **CWE-22:** Path Traversal - https://cwe.mitre.org/data/definitions/22.html
- **OWASP:** Path Traversal - https://owasp.org/www-community/attacks/Path_Traversal

## Acceptance Criteria

- [ ] All file path parameters validated before use
- [ ] Paths resolved with `.resolve()` to prevent symlink attacks
- [ ] Paths checked against allowed directories
- [ ] Clear error messages for invalid paths
- [ ] Security tests added for path traversal attempts
- [ ] Documentation updated with security notes
- [ ] Code review by security-conscious developer

## Work Log

### 2026-02-16 - Initial Discovery

**By:** Claude Code (security-sentinel agent)

**Actions:**
- Identified path traversal vulnerability in file handling
- Analyzed attack vectors and impact
- Researched mitigation strategies
- Drafted 3 solution approaches

**Learnings:**
- Path traversal is a high-severity vulnerability
- Affects multiple functions in analysis.py
- Need comprehensive fix across entire codebase
- Should add security testing to CI

## Notes

- **CRITICAL SECURITY ISSUE** - High severity
- Must be fixed before production deployment
- Consider security audit of entire codebase
- Add path traversal tests to security test suite
- Document security considerations in README
